// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Node from "./Node.bs.js";
import * as WebGL from "./WebGL.bs.js";
import * as Frustum from "./Frustum.bs.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Matrix4 from "./Matrix4.bs.js";
import * as Vector3 from "./Vector3.bs.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Compiled from "./Compiled.bs.js";
import * as TypeArray from "./TypeArray.bs.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";

var varyingRegex = /[^\w](?:varying|out)\s+\w+\s+(\w+)\s*;/g;

function make() {
  var canvas = document.createElement("canvas");
  canvas.width = 1200;
  canvas.height = 1200;
  document.body.appendChild(canvas);
  var gl = canvas.getContext("webgl2");
  return {
          canvas: canvas,
          gl: gl,
          autoClear: true,
          _compiled: Compiled.make(),
          _programs: Compiled.make(),
          _geometry: Compiled.make(),
          _samplers: Compiled.make(),
          _textures: Compiled.make(),
          _buffers: Compiled.make(),
          _fbo: Compiled.make(),
          _textureIndex: 0
        };
}

function setSize(t, width, height) {
  t.canvas.width = width;
  t.canvas.height = height;
  t.gl.viewport(0, 0, width, height);
}

function updateSampler(t, sampler) {
  var maybeTarget = Compiled.get(t._samplers, sampler);
  var target;
  if (maybeTarget !== undefined) {
    target = Caml_option.valFromOption(maybeTarget);
  } else {
    var compiledSampler = t.gl.createSampler();
    Compiled.set(t._samplers, sampler, compiledSampler);
    sampler.needsUpdate = true;
    target = compiledSampler;
  }
  if (sampler.needsUpdate) {
    t.gl.samplerParameri(target, WebGL.gl_TEXTURE_MAG_FILTER, WebGL.gl_filters(sampler.magFilter));
    t.gl.samplerParameri(target, WebGL.gl_TEXTURE_MIN_FILTER, WebGL.gl_filters(sampler.minFilter));
    t.gl.samplerParameri(target, WebGL.gl_TEXTURE_WRAP_S, WebGL.gl_wrappings(sampler.wrapS));
    t.gl.samplerParameri(target, WebGL.gl_TEXTURE_WRAP_T, WebGL.gl_wrappings(sampler.wrapT));
    sampler.needsUpdate = false;
  }
  return target;
}

function updateTexture(t, texture, widthOpt, heightOpt) {
  var width = widthOpt !== undefined ? widthOpt : 0;
  var height = heightOpt !== undefined ? heightOpt : 0;
  var tex = t.gl.createTexture();
  var target = Core__Option.getWithDefault(Compiled.get(t._textures, texture), (texture.needsUpdate = true, Compiled.set(t._textures, texture, tex), tex));
  t.gl.bindTexture(WebGL.gl_TEXTURE_2D, target);
  if (texture.needsUpdate) {
    t.gl.pixelStorei(WebGL.gl_UNPACK_ALIGNMENT, 1);
    var format = Core__Option.getWithDefault(texture.format, WebGL.gl_RGBA);
    var typ = Core__Option.getWithDefault(texture.textureType, WebGL.gl_UNSIGNED_BYTE);
    var img = texture.image;
    if (img !== undefined) {
      t.gl.texImage2D(WebGL.gl_TEXTURE_2D, 0, format, format, typ, img);
    } else {
      t.gl.texImage2D(WebGL.gl_TEXTURE_2D, 0, format, width, height, 0, format, typ);
    }
    var img$1 = texture.image;
    if (img$1 !== undefined && img$1 !== "HTMLVideoElement") {
      texture.needsUpdate = true;
    }
    
  }
  updateSampler(t, texture.sampler);
  return target;
}

function setRenderTarget(t, renderTarget) {
  var maybeFbo = Compiled.get(t._fbo, renderTarget);
  var fbo;
  if (maybeFbo !== undefined) {
    fbo = Caml_option.valFromOption(maybeFbo);
  } else {
    var fbo$1 = t.gl.createFrameBuffer();
    t.gl.bindFramebuffer(WebGL.gl_FRAMEBUFFER, fbo$1);
    var attachments = renderTarget.textures.map(function (texture, i) {
          var attachment = WebGL.gl_COLOR_ATTACHMENT0 + i | 0;
          var target = updateTexture(t, texture, renderTarget.width, renderTarget.height);
          t.gl.framebufferTexture2D(WebGL.gl_FRAMEBUFFER, attachment, WebGL.gl_TEXTURE_2D, target, 0);
          return attachment;
        });
    t.gl.drawBuffers(attachments);
    renderTarget.needsUpdate = false;
    Compiled.set(t._fbo, renderTarget, fbo$1);
    fbo = fbo$1;
  }
  t.gl.bindFramebuffer(WebGL.gl_FRAMEBUFFER, fbo);
  t.gl.viewport(0, 0, renderTarget.width, renderTarget.height);
}

function setDepthTest(t, enabled) {
  if (enabled) {
    t.gl.enable(WebGL.gl_DEPTH_TEST);
    t.gl.depthFunc(WebGL.gl_LESS);
  } else {
    t.gl.disable(WebGL.gl_DEPTH_TEST);
  }
}

function setDepthMask(t, enabled) {
  t.gl.depthMask(enabled);
}

function setCullSide(t, side) {
  switch (side) {
    case "Front" :
    case "Back" :
        break;
    case "Both" :
        t.gl.disable(WebGL.gl_CULL_FACE);
        t.gl.disable(WebGL.gl_DEPTH_TEST);
        return ;
    
  }
  t.gl.enable(WebGL.gl_CULL_FACE);
  t.gl.cullFace(side === "Front" ? WebGL.gl_BACK : WebGL.gl_FRONT);
}

function setBlending(t, blending) {
  if (blending !== undefined) {
    return PervasivesU.failwith("TODO");
  } else {
    t.gl.disable(WebGL.gl_BLEND);
    return ;
  }
}

function setUniform(t, program, name, value) {
  var $$location = t.gl.getUniformLocation(program, name);
  if ($$location === -1) {
    return ;
  }
  switch (value.TAG) {
    case "Single" :
        t.gl.uniform1i($$location, value._0);
        return ;
    case "Array" :
        var value$1 = value._0;
        var match = value$1.length;
        switch (match) {
          case 2 :
              t.gl.uniform2fv($$location, value$1);
              return ;
          case 3 :
              t.gl.uniform3fv($$location, value$1);
              return ;
          case 4 :
              t.gl.uniform4fv($$location, value$1);
              return ;
          case 9 :
              t.gl.uniformMatrix3fv($$location, false, value$1);
              return ;
          case 5 :
          case 6 :
          case 7 :
          case 8 :
          case 10 :
          case 11 :
          case 12 :
          case 13 :
          case 14 :
          case 15 :
              return PervasivesU.failwith("unknown value");
          case 16 :
              t.gl.uniformMatrix4fv($$location, false, value$1);
              return ;
          default:
            return PervasivesU.failwith("unknown value");
        }
    case "Texture" :
        var texture = value._0;
        t._textureIndex = t._textureIndex + 1 | 0;
        var index = t._textureIndex;
        t.gl.activeTexture(WebGL.gl_TEXTURE0 + index | 0);
        var sampler = Compiled.get(t._samplers, texture.sampler);
        if (sampler !== undefined) {
          t.gl.bindSampler(index, Caml_option.valFromOption(sampler));
        }
        updateTexture(t, texture, undefined, undefined);
        t.gl.uniform1i($$location, index);
        return ;
    
  }
}

function compile(t, mesh, meshNode, camera) {
  mesh.material.uniforms["modelMatrix"] = {
    TAG: "Array",
    _0: meshNode.matrix
  };
  mesh.material.uniforms["projectionMatrix"] = {
    TAG: "Array",
    _0: camera.projectionMatrix
  };
  mesh.material.uniforms["viewMatrix"] = {
    TAG: "Array",
    _0: camera.viewMatrix
  };
  mesh.material.uniforms["normalMatrix"] = {
    TAG: "Array",
    _0: mesh.normalMatrix
  };
  mesh.material.uniforms["modelViewMatrix"] = {
    TAG: "Array",
    _0: mesh.modelViewMatrix
  };
  Matrix4.multiply(Matrix4.copy(mesh.modelViewMatrix, camera.viewMatrix), meshNode.matrix);
  Matrix4.normal(mesh.normalMatrix, mesh.modelViewMatrix);
  var compiled = Compiled.get(t._compiled, mesh);
  var program = Compiled.get(t._programs, mesh.material);
  var program$1;
  if (program !== undefined) {
    program$1 = Caml_option.valFromOption(program);
  } else {
    var program$2 = t.gl.createProgram();
    Compiled.set(t._programs, mesh.material, program$2);
    var vertexShader = t.gl.createShader(WebGL.gl_VERTEX_SHADER);
    t.gl.shaderSource(vertexShader, mesh.material.vertex);
    t.gl.compileShader(vertexShader);
    t.gl.attachShader(program$2, vertexShader);
    var fragmentShader = t.gl.createShader(WebGL.gl_FRAGMENT_SHADER);
    t.gl.shaderSource(fragmentShader, mesh.material.fragment);
    t.gl.compileShader(fragmentShader);
    t.gl.attachShader(program$2, fragmentShader);
    t.gl.linkProgram(program$2);
    var error = t.gl.getShaderInfoLog(fragmentShader);
    console.log(error);
    var error$1 = t.gl.getShaderInfoLog(vertexShader);
    console.log(error$1);
    var error$2 = t.gl.getProgramInfoLog(program$2);
    console.log(error$2);
    t.gl.deleteShader(vertexShader);
    t.gl.deleteShader(fragmentShader);
    program$1 = program$2;
  }
  var vao = Compiled.get(t._geometry, mesh.geometry);
  var vao$1;
  if (vao !== undefined) {
    vao$1 = Caml_option.valFromOption(vao);
  } else {
    var vao$2 = t.gl.createVertexArray();
    Compiled.set(t._geometry, mesh.geometry, vao$2);
    vao$1 = vao$2;
  }
  t.gl.useProgram(program$1);
  t.gl.bindVertexArray(vao$1);
  Js_dict.entries(mesh.geometry.attributes).forEach(function (param) {
        var attribute = param[1];
        var key = param[0];
        var typ = key === "index" ? WebGL.gl_ELEMENT_ARRAY_BUFFER : WebGL.gl_ARRAY_BUFFER;
        var buffer = Compiled.get(t._buffers, attribute);
        var buffer$1;
        if (buffer !== undefined) {
          buffer$1 = Caml_option.valFromOption(buffer);
        } else {
          var buffer$2 = t.gl.createBuffer();
          Compiled.set(t._buffers, attribute, buffer$2);
          t.gl.bindBuffer(typ, buffer$2);
          var arr = attribute.data;
          t.gl.bufferData(typ, arr._0, WebGL.gl_STATIC_DRAW);
          attribute.needsUpdate = false;
          buffer$1 = buffer$2;
        }
        var maybeCompiledProgram = Core__Option.flatMap(compiled, (function (it) {
                return Caml_option.some(it.program);
              }));
        var maybeCompiledVao = Core__Option.flatMap(compiled, (function (it) {
                return Caml_option.some(it.vao);
              }));
        if (Caml_obj.notequal(program$1, maybeCompiledProgram) || Caml_obj.notequal(vao$1, maybeCompiledVao)) {
          t.gl.bindBuffer(typ, buffer$1);
          var $$location = t.gl.getAttribLocation(program$1, key);
          if ($$location !== -1) {
            var slots = Math.min(4.0, Math.max(1.0, Math.floor(attribute.size / 3.0))) | 0;
            for(var i = 0; i < slots; ++i){
              t.gl.enableVertexAttribArray($$location + i | 0);
              var stride = Math.imul(attribute.size, TypeArray.bytesPerElement(attribute.data));
              var offset = Math.imul(attribute.size, i);
              if (WebGL.gl_FLOAT === WebGL.gl_FLOAT) {
                t.gl.vertexAttribPointer($$location, attribute.size, WebGL.gl_FLOAT, false, stride, offset);
              } else {
                t.gl.vertexAttribIPointer($$location, attribute.size, WebGL.gl_FLOAT, stride, offset);
              }
              var divisor = attribute.divisor;
              if (divisor !== undefined) {
                t.gl.vertexAttribDivisor($$location + i | 0, divisor);
              }
              
            }
          }
          
        }
        if (!attribute.needsUpdate) {
          return ;
        }
        t.gl.bindBuffer(typ, buffer$1);
        var arr$1 = attribute.data;
        t.gl.bufferData(typ, arr$1._0, WebGL.gl_DYNAMIC_DRAW);
        attribute.needsUpdate = false;
      });
  t._textureIndex = 0;
  Js_dict.entries(mesh.material.uniforms).forEach(function (param) {
        setUniform(t, program$1, param[0], param[1]);
      });
  if (compiled !== undefined) {
    return compiled;
  }
  var comp = {
    program: program$1,
    vao: vao$1
  };
  Compiled.set(t._compiled, mesh, comp);
  return comp;
}

function clear(t) {
  var bits = WebGL.gl_COLOR_BUFFER_BIT | WebGL.gl_DEPTH_BUFFER_BIT | WebGL.gl_STENCIL_BUFFER_BIT;
  t.gl.clear(bits);
}

function sort(param, scene, camera) {
  var cam = $$Node.unpack(camera.kind);
  if (camera.matrixAutoUpdate) {
    Matrix4.multiply(Matrix4.copy(cam.projectionViewMatrix, cam.projectionMatrix), cam.viewMatrix);
    Frustum.fromMatrix4(cam.frustum, cam.projectionViewMatrix);
  }
  var renderList = scene.flatMap(function (it) {
        var match = it.kind;
        if (typeof match === "object") {
          if (match.NAME === "Mesh") {
            if (it.visible) {
              return [[
                        it,
                        match.VAL
                      ]];
            } else {
              return [];
            }
          } else {
            return [];
          }
        } else {
          return [];
        }
      });
  var v = Vector3.make(0.0, 0.0, 0.0);
  renderList.sort(function (param, param$1) {
        var bNode = param$1[0];
        var aNode = param[0];
        return Vector3.applyMatrix4(Vector3.set(v, bNode.matrix[12], bNode.matrix[13], bNode.matrix[14]), cam.projectionViewMatrix).z - Vector3.applyMatrix4(Vector3.set(v, aNode.matrix[12], aNode.matrix[13], aNode.matrix[14]), cam.projectionViewMatrix).z;
      });
  return renderList;
}

function getDataType(arr) {
  if (arr.TAG === "Float32Array") {
    return WebGL.gl_FLOAT;
  } else {
    return WebGL.gl_UNSIGNED_SHORT;
  }
}

function render(t, scene, camera) {
  if (t.autoClear) {
    clear(t);
  }
  scene.children.forEach(function (it) {
        $$Node.updateMatrix(it);
      });
  $$Node.updateMatrix(camera);
  var renderList = sort(t, scene.children, camera);
  renderList.forEach(function (param) {
        var mesh = param[1];
        var node = param[0];
        $$Node.updateMatrix(node);
        compile(t, mesh, node, $$Node.unpack(camera.kind));
        setDepthTest(t, mesh.material.depthTest);
        setDepthMask(t, mesh.material.depthWrite);
        setCullSide(t, mesh.material.side);
        setBlending(t, mesh.material.blending);
        var mode = t.gl.TRIANGLES;
        var index = Js_dict.get(mesh.geometry.attributes, "index");
        var match = mesh.geometry.drawRange;
        if (index !== undefined) {
          t.gl.drawElements(mode, Math.min(match.count, Caml_int32.div(TypeArray.length(index.data), index.size)) | 0, getDataType(index.data), match.start);
          return ;
        }
        
      });
}

export {
  varyingRegex ,
  make ,
  setSize ,
  updateSampler ,
  updateTexture ,
  setRenderTarget ,
  setDepthTest ,
  setDepthMask ,
  setCullSide ,
  setBlending ,
  setUniform ,
  compile ,
  clear ,
  sort ,
  getDataType ,
  render ,
}
/* Node Not a pure module */
